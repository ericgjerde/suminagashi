<!DOCTYPE html>
<html>
<head>
    <title>Standalone WebGL Test</title>
    <style>
        body { margin: 20px; background: #1a1a1a; color: #fff; font-family: monospace; }
        canvas { border: 3px solid #ff0000; display: block; margin: 20px 0; background: #000; }
        #status { background: #333; padding: 15px; margin: 20px 0; border-radius: 5px; }
        .success { color: #0f0; }
        .error { color: #f00; }
        button { padding: 10px 20px; margin: 5px; font-size: 14px; }
    </style>
</head>
<body>
    <h1>Standalone WebGL Test - No app.js</h1>
    <div id="status">Initializing...</div>
    
    <canvas id="testCanvas" width="600" height="400"></canvas>
    
    <div>
        <button onclick="test1()">Test 1: Clear to Red</button>
        <button onclick="test2()">Test 2: Draw Triangle</button>
        <button onclick="test3()">Test 3: Draw Textured Quad</button>
    </div>
    
    <script>
        const status = document.getElementById('status');
        const canvas = document.getElementById('testCanvas');
        
        function log(msg, type = '') {
            const className = type ? ` class="${type}"` : '';
            status.innerHTML += `<div${className}>${msg}</div>`;
            console.log(msg);
        }
        
        // Get WebGL2 context
        log('Getting WebGL2 context...');
        const gl = canvas.getContext('webgl2', { 
            alpha: false, 
            antialias: false,
            depth: false,
            preserveDrawingBuffer: true 
        });
        
        if (!gl) {
            log('WebGL2 NOT supported!', 'error');
        } else {
            log('WebGL2 context obtained!', 'success');
            
            // Check renderer info
            const dbg = gl.getExtension('WEBGL_debug_renderer_info');
            if (dbg) {
                const renderer = gl.getParameter(dbg.UNMASKED_RENDERER_WEBGL);
                const vendor = gl.getParameter(dbg.UNMASKED_VENDOR_WEBGL);
                log(`GPU: ${vendor} / ${renderer}`, 'success');
            }
            
            // Initial clear
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0.0, 0.0, 0.3, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            log('Canvas cleared to dark blue', 'success');
        }
        
        function test1() {
            log('<br>TEST 1: Clearing to red...');
            if (!gl) {
                log('No WebGL context!', 'error');
                return;
            }
            
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(1.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            log('Canvas should now be RED', 'success');
        }
        
        function test2() {
            log('<br>TEST 2: Drawing triangle...');
            if (!gl) {
                log('No WebGL context!', 'error');
                return;
            }
            
            // Vertex shader
            const vsSource = `#version 300 es
                in vec2 aPosition;
                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);
                }`;
            
            // Fragment shader  
            const fsSource = `#version 300 es
                precision mediump float;
                out vec4 fragColor;
                void main() {
                    fragColor = vec4(0.0, 1.0, 0.0, 1.0);
                }`;
            
            // Compile shaders
            const vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, vsSource);
            gl.compileShader(vs);
            if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
                log('VS compile error: ' + gl.getShaderInfoLog(vs), 'error');
                return;
            }
            
            const fs = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fs, fsSource);
            gl.compileShader(fs);
            if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
                log('FS compile error: ' + gl.getShaderInfoLog(fs), 'error');
                return;
            }
            
            // Link program
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.bindAttribLocation(program, 0, 'aPosition');
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                log('Link error: ' + gl.getProgramInfoLog(program), 'error');
                return;
            }
            
            // Create triangle
            const vertices = new Float32Array([
                 0.0,  0.5,
                -0.5, -0.5,
                 0.5, -0.5
            ]);
            
            const vao = gl.createVertexArray();
            gl.bindVertexArray(vao);
            
            const vbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
            
            // Draw
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            gl.useProgram(program);
            gl.bindVertexArray(vao);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
            
            log('Green triangle drawn on black background', 'success');
            
            // Cleanup
            gl.deleteProgram(program);
            gl.deleteShader(vs);
            gl.deleteShader(fs);
            gl.deleteVertexArray(vao);
            gl.deleteBuffer(vbo);
        }
        
        function test3() {
            log('<br>TEST 3: Drawing textured quad...');
            if (!gl) {
                log('No WebGL context!', 'error');
                return;
            }
            
            // Create a simple checkerboard texture
            const size = 64;
            const data = new Uint8Array(size * size * 4);
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const i = (y * size + x) * 4;
                    const checker = ((x >> 3) ^ (y >> 3)) & 1;
                    const val = checker ? 255 : 0;
                    data[i] = val;
                    data[i + 1] = checker ? 0 : 255;
                    data[i + 2] = 128;
                    data[i + 3] = 255;
                }
            }
            
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            
            // Shaders
            const vsSource = `#version 300 es
                in vec2 aPosition;
                out vec2 vUV;
                void main() {
                    vUV = aPosition * 0.5 + 0.5;
                    gl_Position = vec4(aPosition, 0.0, 1.0);
                }`;
            
            const fsSource = `#version 300 es
                precision mediump float;
                in vec2 vUV;
                out vec4 fragColor;
                uniform sampler2D uTexture;
                void main() {
                    fragColor = texture(uTexture, vUV);
                }`;
            
            // Compile shaders
            const vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, vsSource);
            gl.compileShader(vs);
            
            const fs = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fs, fsSource);
            gl.compileShader(fs);
            
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.bindAttribLocation(program, 0, 'aPosition');
            gl.linkProgram(program);
            
            // Create quad
            const vertices = new Float32Array([
                -0.8, -0.8,
                 0.8, -0.8,
                -0.8,  0.8,
                 0.8, -0.8,
                 0.8,  0.8,
                -0.8,  0.8
            ]);
            
            const vao = gl.createVertexArray();
            gl.bindVertexArray(vao);
            
            const vbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
            
            // Draw
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0.2, 0.2, 0.2, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            gl.useProgram(program);
            gl.uniform1i(gl.getUniformLocation(program, 'uTexture'), 0);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.bindVertexArray(vao);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            
            log('Checkerboard pattern drawn', 'success');
            
            // Cleanup
            gl.deleteProgram(program);
            gl.deleteShader(vs);
            gl.deleteShader(fs);
            gl.deleteVertexArray(vao);
            gl.deleteBuffer(vbo);
            gl.deleteTexture(texture);
        }
        
        // Run first test automatically
        setTimeout(() => {
            log('<br>Auto-running Test 1...');
            test1();
        }, 500);
    </script>
</body>
</html>